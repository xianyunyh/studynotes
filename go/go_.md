## 并发

在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做**临界区** ，使用互斥锁限定临界区只能有一个线程拥有。

- 共享资源。并发读写共享资源。出现数据竞争，需要mutex、rwmutex保护
- 任务编排，需要waitgroup、Channel实现
- 消息传递 信息交流以及不同的goroutine之间的线程安全

## Mutex

如果嵌入的 struct 有多个字段，我们一般会把 Mutex 放在要控制的字段上面，然后使用空格把字段分隔开来，还可以把获取锁、释放锁、计数加一的逻辑封装成一个方法，对外不需要暴露锁



等待的goroutine们是以FIFO排队的 

1）当Mutex处于正常模式时，若此时没有新goroutine与队头goroutine竞争，则队头goroutine获得。若有新goroutine竞争大概率新goroutine获得。

 2）当队头goroutine竞争锁失败1ms后，它会将Mutex调整为饥饿模式。进入饥饿模式后，锁的所有权会直接从解锁goroutine移交给队头goroutine，此时新来的goroutine直接放入队尾。

 3）当一个goroutine获取锁后，如果发现自己满足下列条件中的任何一个#1它是队列中最后一个#2它等待锁的时间少于1ms，则将锁切换回正常模式 



CAS 指令将给定的值和一个内存地址中的值进行比较，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的。那啥是原子性呢？如果你还不太理解这个概念，那么在这里只需要明确一点就行了，那就是原子性保证这个指令总是基于最新的值进行计算，如果同时有其它线程已经修改了这个值，那么，CAS 会返回失败 

> Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今。 



mutex锁 一定要遵循“谁申请，谁释放”的原则。



Mutex 增加了饥饿模式，让锁变得更公平，不公平的等待时间限制在 1 毫秒，一旦等待者等待的时间超过了这个阈值，Mutex 的处理就有可能进入饥饿模式，优先让等待者先获取到锁 



### 错误使用锁的情况

- 没有成对出现
- copy 已使用mutex，锁是有状态的，复制锁，锁的状态也会复制



死锁产生的必要条件。如果你想避免死锁，只要破坏这四个条件中的一个或者几个，就可以了。

互斥： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。

持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。

不可剥夺：资源只能由持有它的 goroutine 来释放。

环路等待：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，最后是 PN 等待 P1 持有的资源，这就形成了一个环路等待的死结 



### WaitGroup 

- 不重用 WaitGroup 
- 不传递负数给 Add 方法，只通过 Done 来给计数值减 1 
- 不做多余的 Done 方法调用，保证 Add 的计数值和 Done 方法调用的数量是一样的 
- 不遗漏 Done 方法的调用，否则会导致 Wait hang 住无法返回 

- WaitGroup 使用之后不要复制 

